---
- hosts: "localhost"
  connection: local
  gather_facts: false
  vars_files:
    - vars.yaml
  vars:
    # terraform integration (optional).
    terraform_workspace: "{{ lookup('env', 'TF_WORKSPACE') | default('') }}"
    use_terraform: "{{ terraform_workspace != '' and terraform_workspace is defined }}"
    terraform_state_file: "{{ (lookup('env', 'TERRAFORM_NODE_SOURCE') | default('tofu/aws/modules/cluster_nodes')) + '/terraform.tfstate.d/' + terraform_workspace + '/terraform.tfstate' if use_terraform else '' }}"

    # Use the constructed path in the lookups.
    fqdn_default: "{{ lookup('cloud.terraform.tf_output', 'fqdn', state_file=terraform_state_file) if use_terraform else (lookup('env', 'FQDN') | default(lookup('env', 'KUBE_API_HOST'), true)) }}"
    kube_api_host: "{{ lookup('cloud.terraform.tf_output', 'kube_api_host', state_file=terraform_state_file) if use_terraform else lookup('env', 'KUBE_API_HOST') }}"
    ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
  tasks:
    - name: Validate required variables
      assert:
        that:
          - kubernetes_version is defined
          - kubernetes_version | length > 0
          - kube_api_host is defined
          - kube_api_host | length > 0
          - cni is defined
          - cni | length > 0
        fail_msg: "Required variables not defined. Please ensure kubernetes_version, kube_api_host, and cni are set in vars.yaml or environment variables"

    - name: Wait for SSH on node
      wait_for:
        host: "{{ kube_api_host }}"
        port: 22
        timeout: 300
        state: started
      loop: "{{ groups['all'] }}"

    - name: Get LoadBalancer IP (only for Harvester clusters)
      command: >
        kubectl get loadbalancer {{ fqdn_default }} -o jsonpath='{.status.address}'
      register: lb_ip_result
      environment:
        KUBECONFIG: "{{ lookup('env', 'PWD') }}/{{ terraform_state_file }}/../../../../local.yaml"
      when: "'harvester' in lookup('env', 'TERRAFORM_NODE_SOURCE')"

    - name: Get normalized IP (if any)
      set_fact:
        lb_ip_normalized: "{{ (lb_ip_result.get('stdout', '') | default('')) if (lb_ip_result is defined and lb_ip_result is mapping) else '' }}"

    - name: Normalize fqdn
      set_fact:
        fqdn_final: >-
          {{
            (lb_ip_normalized | length > 0)
              | ternary(lb_ip_normalized ~ '.sslip.io', fqdn_default)
          }}


- hosts: "master"
  become: true
  gather_facts: false
  vars_files:
    - vars.yaml
  vars:
    # terraform integration (optional).
    terraform_workspace: "{{ lookup('env', 'TF_WORKSPACE') | default('') }}"
    use_terraform: "{{ terraform_workspace != '' and terraform_workspace is defined }}"
    terraform_state_file: "{{ (lookup('env', 'TERRAFORM_NODE_SOURCE') | default('tofu/aws/modules/cluster_nodes')) + '/terraform.tfstate.d/' + terraform_workspace + '/terraform.tfstate' if use_terraform else '' }}"

    kube_api_host: "{{ lookup('cloud.terraform.tf_output', 'kube_api_host', state_file=terraform_state_file) if use_terraform else lookup('env', 'KUBE_API_HOST') }}"
    fqdn: "{{ lookup('cloud.terraform.tf_output', 'fqdn', state_file=terraform_state_file) if use_terraform else hostvars['localhost']['fqdn_final'] }}"
    node_token_file: "/tmp/node_token.txt" # Local file to store the token
    ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
  tasks:
    - name: Transfer and execute init-cluster.sh (initial etcd node)
      script: ./init-cluster.sh
      environment:
        KUBERNETES_VERSION: "{{ kubernetes_version }}"
        KUBE_API_HOST: "{{ kube_api_host }}"
        FQDN: "{{ fqdn }}"
        CNI: "{{ cni }}"
        NODE_ROLE: "{{ ansible_role }}"
        PUBLIC_IP: "{{ ansible_host }}"
        CHANNEL: "{{ channel | default('') }}"
        SERVER_FLAGS: "{{ server_flags | default('') }}"
        INSTALL_METHOD: "{{ install_method | default('') }}"
      register: script_result

    - name: Display script output (stdout)
      debug:
        var: script_result.stdout_lines

    - name: Check script return code
      debug:
        msg: "Script returned: {{ script_result.rc }}"

    - name: Display script errors (stderr) if any
      debug:
        var: script_result.stderr_lines
      when: script_result.rc != 0

    - name: Get node-token from master
      raw: cat /var/lib/rancher/rke2/server/node-token 2>/dev/null
      register: node_token_output

    - name: Save node_token to local file
      delegate_to: localhost
      run_once: true
      become: no
      shell: echo "{{ node_token_output.stdout }}" > "{{ node_token_file }}"

    - name: Read file contents into a variable
      raw: cat /etc/rancher/rke2/rke2.yaml 2>/dev/null
      register: file_contents

    - name: Save file contents locally
      delegate_to: localhost
      run_once: true
      become: no
      shell: echo "{{ file_contents.stdout }}" > "{{ kubeconfig_file }}"

- hosts: "all"
  become: true
  gather_facts: false
  vars_files:
    - vars.yaml
  vars:
    # tf integration (optional).
    terraform_workspace: "{{ lookup('env', 'TF_WORKSPACE') | default('') }}"
    use_terraform: "{{ terraform_workspace != '' and terraform_workspace is defined }}"
    terraform_state_file: "{{ (lookup('env', 'TERRAFORM_NODE_SOURCE') | default('tofu/aws/modules/cluster_nodes')) + '/terraform.tfstate.d/' + terraform_workspace + '/terraform.tfstate' if use_terraform else '' }}"

    kube_api_host: "{{ lookup('cloud.terraform.tf_output', 'kube_api_host', state_file=terraform_state_file) if use_terraform else lookup('env', 'KUBE_API_HOST') }}"
    fqdn: "{{ lookup('cloud.terraform.tf_output', 'fqdn', state_file=terraform_state_file) if use_terraform else hostvars['localhost']['fqdn_final'] }}"
    server_host: "{{ server_host_override | default((groups['all'] | selectattr('terraform_facts.output_nodes.value[inventory_hostname].is_server', 'defined') | selectattr('terraform_facts.output_nodes.value[inventory_hostname].is_server', 'true') | map('inventory_hostname') | list)[0] if use_terraform else groups['master'][0]) }}"
    node_token_file: "/tmp/node_token.txt" # Local file to store the token
    ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
  tasks:
    - name: Read node_token from local file
      delegate_to: localhost
      run_once: true
      become: false
      slurp:
        src: "{{ node_token_file }}"
      register: node_token_file_content

    - name: Set node_token fact from file content
      set_fact:
        node_token: "{{ node_token_file_content.content | b64decode | trim }}"
      run_once: true
      delegate_to: localhost

    - name: Transfer and execute init-server.sh (Server)
      script: ./init-server.sh
      environment:
        KUBERNETES_VERSION: "{{ kubernetes_version }}"
        KUBE_API_HOST: "{{ kube_api_host }}"
        FQDN: "{{ fqdn }}"
        CNI: "{{ cni }}"
        NODE_TOKEN: "{{ node_token }}"
        NODE_ROLE: "{{ ansible_role }}"
        PUBLIC_IP: "{{ ansible_host }}"
        SERVER_FLAGS: "{{ server_flags | default('') }}"
        CHANNEL: "{{ channel | default('') }}"
        INSTALL_METHOD: "{{ install_method | default('') }}"
      register: script_result
      when: >
        "master" not in inventory_hostname and
        (
          ansible_role is defined and
          (
            "cp" in ansible_role.split(',') or
            "etcd" in ansible_role.split(',')
          )
        )

    - name: Transfer and execute init-agent.sh (Agent)
      script: ./init-agent.sh
      environment:
        KUBERNETES_VERSION: "{{ kubernetes_version }}"
        KUBE_API_HOST: "{{ kube_api_host }}"
        FQDN: "{{ fqdn }}"
        CNI: "{{ cni }}"
        NODE_TOKEN: "{{ node_token }}"
        PUBLIC_IP: "{{ ansible_host }}"
        WORKER_FLAGS: "{{ worker_flags | default('') }}"
        CHANNEL: "{{ channel | default('') }}"
        INSTALL_METHOD: "{{ install_method | default('') }}"
      register: script_result
      when: ansible_role == "worker"

- hosts: localhost
  connection: local
  gather_facts: false
  vars_files:
    - vars.yaml
  tasks:
    - name: Wait until all RKE2 Helm-managed pods in kube-system are Running or Succeeded
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig_file }}"
        api_version: v1
        kind: Pod
        namespace: kube-system
        label_selectors:
          - app.kubernetes.io/managed-by=Helm
      register: rke2_pods_check
      until: >
        rke2_pods_check.resources is defined and
        (rke2_pods_check.resources | rejectattr('status.phase', 'in', ['Running', 'Succeeded']) | list | length == 0)
      retries: 5
      delay: 60
      
    - name: Wait for ingress-nginx admission webhook to be ready
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig_file }}"
        api_version: v1
        kind: Endpoints
        namespace: kube-system
        name: rke2-ingress-nginx-controller-admission
      register: ingress_endpoints
      until: >
        ingress_endpoints.resources | length > 0 and
        (ingress_endpoints.resources[0].subsets | default([])) | length > 0 and
        (ingress_endpoints.resources[0].subsets[0].addresses | default([])) | length > 0
      retries: 30
      delay: 20